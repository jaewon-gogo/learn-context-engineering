# ADR-001: 스포츠팀 경기일정 캘린더 웹사이트 아키텍처 결정

## 배경

### 결정이 필요한 배경

10살 아들이 좋아하는 스포츠팀의 경기일정을 자동으로 수집하여 캘린더 형태로 시각화하는 웹 애플리케이션을 개발합니다. 현재는 여러 웹사이트를 수동으로 방문하여 텍스트 형태의 정보를 확인해야 하는 불편함이 있으며, 이를 자동화하고 시각화하는 것이 목표입니다.

### 현재의 과제

1. **정보 수집의 번거로움**: 여러 웹사이트를 직접 방문하여 경기일정 확인
2. **시각화 부족**: 텍스트 형태로만 제공되어 한눈에 파악하기 어려움
3. **사용자 경험**: 10살 아동이 이해하기 쉬운 직관적인 UI/UX 필요
4. **캘린더 연동**: 경기일정을 iCloud 캘린더에 자동으로 동기화하여 다른 기기에서도 확인 가능하도록 필요

### 아키텍처 드라이버 개요

#### 제약 사항

**비즈니스상의 제약**:
- **프로젝트 예산**: 미정 (개인/가족 프로젝트로 저예산 가정)
- **일정**: 미정 (긴급하지 않음)
- **릴리스 마감일**: 없음
- **운영 후 유지보수 비용**: 최소화 필요
- **법규 대응**: 특별한 법규 요구사항 없음 (단, 웹 크롤링 시 robots.txt 및 이용약관 준수 필요)

**기술적인 제약**:
- **프로그래밍 언어**: 미정 (선택 필요)
- **사용 가능한 라이브러리·프레임워크**: 미정
- **환경**: 미정 (로컬/클라우드 선택 필요)
- **기존 시스템과의 연계**: 없음

#### 품질 특성

**가용성(신뢰성)**:
- 가동률: 높은 가용성 요구 없음 (개인용 프로젝트)
- 장애 복구 시간: 즉각적 복구 불필요 (수동 재시작 가능)

**성능**:
- 응답 시간: 2초 이내 (일반 웹사이트 수준)
- 처리량: 동시 사용자 수 적음 (개인/가족 사용)
- 크롤링 속도: 일별 또는 주별 크롤링으로 충분

**보안**:
- 인증 방식: ✅ **iCloud OAuth 2.0 인증 필요** (사용자 요구사항 변경)
- 데이터 보호: 
  - iCloud OAuth 토큰 안전한 저장 (암호화 필요)
  - 사용자별 데이터 격리 필요
- 크롤링 시 robots.txt 준수 및 적절한 요청 간격 유지
- iCloud Calendar API 호출 시 Rate Limiting 준수

**유지보수성**:
- 크롤링 대상 사이트 변경에 대응 가능한 구조 필요
- 코드 가독성 및 간결성 중시

**이식성**:
- 다른 환경으로의 이전 용이성: 중간 정도 중요

**분산 시스템 요구사항**:
- 실시간성: 불필요 (일별/주별 업데이트 충분)
- 지연 요구사항: 없음

**환경 요구사항**:
- 모바일 및 데스크톱 브라우저 지원
- 반응형 디자인 필수

#### 아키텍처에 영향을 주는 기능 요구사항

1. **인증 시스템**: ✅ iCloud 계정으로 로그인 (OAuth 2.0)
2. **사용자 입력 인터페이스**: 스포츠 종목 및 팀 선택
3. **웹 크롤링**: 경기일정 데이터 자동 수집
4. **데이터 파싱 및 저장**: 수집한 데이터 정제 및 저장
5. **캘린더 시각화**: 경기일정을 캘린더 형태로 표시
6. **외부 캘린더 연동**: ✅ iCloud Calendar API를 통한 경기일정 자동 전송
7. **반응형 UI**: 모바일 및 데스크톱 지원

**향후 기능 확장 계획**:
- 다중 팀 지원 (선택)
- 경기 결과 표시 (선택)
- 알림/리마인더 기능 (선택)

#### 기타 영향 요소

- **개발 팀의 기술 수준**: 개인 개발자 (부모)
- **운영 팀의 체제**: 개발자 본인이 운영
- **이해관계자의 요구**: 10살 아동의 사용성 중시

## 결정 내용

### 선택한 아키텍처 패턴

**모놀리식 아키텍처**를 선택했습니다.

이유:
- 소규모 개인 프로젝트로 복잡한 분산 아키텍처 불필요
- 개발 및 운영 비용 최소화
- 단일 애플리케이션으로 충분한 기능 제공
- 빠른 개발 및 배포 가능

### 주요 구성 요소 구성

```
┌─────────────────────────────────────────┐
│         Frontend (Web UI)                │
│  - React/Vue/Angular 또는 순수 JS        │
│  - 캘린더 컴포넌트                       │
│  - 사용자 입력 인터페이스                │
│  - iCloud OAuth 로그인 UI                │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Backend (API Server)             │
│  - RESTful API                            │
│  - OAuth 2.0 인증 처리                    │
│  - 크롤링 스케줄러                        │
│  - 데이터 파싱 로직                       │
│  - iCloud Calendar API 클라이언트         │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Data Layer                       │
│  - 파일 시스템 또는 경량 DB              │
│  - 크롤링 데이터 캐시                     │
│  - 사용자 인증 정보 (암호화)              │
│  - iCloud OAuth 토큰 (암호화)            │
└─────────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         External APIs                    │
│  - iCloud Calendar API                   │
│  - Apple OAuth 2.0 서버                  │
└─────────────────────────────────────────┘
```

### 인프라

**배포 환경 옵션** (선택 필요):
1. **로컬 환경**: 개발자 PC에서 실행
2. **클라우드 호스팅**: Vercel, Netlify, GitHub Pages (정적 호스팅)
3. **클라우드 서버**: AWS, GCP, Azure (서버리스 또는 전통적 서버)

**추천**: 초기 단계에서는 **정적 호스팅 + 서버리스 함수** 조합
- Vercel/Netlify: 프론트엔드 호스팅
- 서버리스 함수: 크롤링 작업 (예: Vercel Functions, AWS Lambda)

### 데이터 흐름

```
사용자 입력 (스포츠 종목, 팀)
    ↓
Frontend → API 요청
    ↓
Backend → 크롤링 작업 실행 (또는 캐시된 데이터 반환)
    ↓
데이터 파싱 및 정제
    ↓
데이터 저장 (캐시)
    ↓
Frontend에 JSON 응답
    ↓
캘린더 UI에 데이터 표시
```

## 상태

**제안** (승인 대기)

## 선정 이유

### 아키텍처 비교 평가 결과

| 평가 항목 | 모놀리식 | 마이크로서비스 | 서버리스 |
|----------|---------|--------------|---------|
| 개발 시간 | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 운영 복잡도 | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 비용 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 확장성 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 유지보수성 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |

**결론**: 개인 프로젝트의 특성상 **모놀리식 아키텍처**가 가장 적합합니다.

### 선정한 이유의 상세 설명

1. **개발 효율성**: 단일 코드베이스로 빠른 개발 가능
2. **운영 단순성**: 배포 및 모니터링이 간단
3. **비용 효율성**: 추가 인프라 비용 최소화
4. **충분한 기능 제공**: 현재 요구사항을 모놀리식으로 충분히 충족
5. **향후 확장 가능**: 필요 시 점진적으로 마이크로서비스로 전환 가능

## 영향

### 이 결정의 영향

**긍정적 영향**:
- 빠른 개발 및 배포 가능
- 간단한 운영 및 유지보수
- 낮은 운영 비용

**부정적 영향**:
- 대규모 확장 시 제약 가능
- 단일 장애점 존재

### 개발 프로세스에 미치는 영향

- 단일 저장소로 코드 관리 간소화
- 통합 테스트 용이
- 배포 프로세스 단순화

### 운영에 미치는 영향

- 단일 애플리케이션 모니터링
- 로그 관리 용이
- 장애 대응 단순화

### 향후 확장성에 미치는 영향

- 초기 단계에서는 충분
- 사용자 증가 또는 기능 확장 시 점진적 리팩토링 가능
- 마이크로서비스 전환 가능 (필요 시)

## 비기능 요구사항 대응

### 가용성 대응

- 개인 프로젝트 특성상 높은 가용성 불필요
- 서버리스 함수 사용 시 자동 스케일링 활용
- 정적 호스팅으로 프론트엔드 고가용성 확보

### 성능 대응

- 캐싱 전략으로 크롤링 빈도 최소화
- 정적 파일 CDN 활용
- 클라이언트 사이드 렌더링으로 빠른 응답

### 보안 대응

- 크롤링 시 robots.txt 준수
- 적절한 요청 간격 유지 (Rate Limiting)
- 사용자 입력 검증 및 Sanitization
- HTTPS 사용

### 기타 중요한 비기능 요건 대응

**사용성**: 10살 아동을 위한 직관적 UI
**접근성**: 모바일 및 데스크톱 반응형 디자인
**유지보수성**: 크롤링 대상 사이트 변경에 대응 가능한 구조

## 대안

### 고려한 다른 아키텍처 패턴

#### 1. 마이크로서비스 아키텍처

**선택하지 않은 이유**:
- 소규모 프로젝트에 과도한 복잡성
- 개발 및 운영 비용 증가
- 불필요한 오버헤드

#### 2. 서버리스 아키텍처 (함수 중심)

**고려 사항**:
- 장점: 자동 스케일링, 비용 효율적 (사용량 기반)
- 단점: 콜드 스타트, 디버깅 복잡성

**최종 판단**: 서버리스 함수를 크롤링 작업에 활용하는 하이브리드 접근 가능

## 기술 스택

### 채택하는 언어/프레임워크 (추천)

**프론트엔드**:
- **옵션 1**: React + TypeScript (권장)
  - 풍부한 캘린더 라이브러리 (react-big-calendar, fullcalendar-react)
  - 활발한 커뮤니티
- **옵션 2**: Vue.js + TypeScript
- **옵션 3**: 순수 JavaScript (간단한 프로젝트)

**백엔드**:
- **옵션 1**: Node.js + Express (권장)
  - 프론트엔드와 동일한 언어로 풀스택 개발 가능
  - 크롤링 라이브러리 풍부 (Puppeteer, Cheerio)
- **옵션 2**: Python + Flask/FastAPI
  - 크롤링에 최적화 (BeautifulSoup, Scrapy)
  - 데이터 처리에 강점
- **옵션 3**: 서버리스 함수 (Vercel Functions, AWS Lambda)

**크롤링 라이브러리**:
- Node.js: Puppeteer, Cheerio, Axios
- Python: BeautifulSoup, Scrapy, Selenium

**인증 및 외부 API 라이브러리**:
- **OAuth 2.0**: 
  - Node.js: `passport`, `passport-apple`, `simple-oauth2`
  - Python: `authlib`, `requests-oauthlib`
- **iCloud Calendar API**:
  - Node.js: `node-ical` (iCal 파싱), `ical-generator` (iCal 생성)
  - Python: `icalendar` (iCal 파싱/생성)
  - 직접 REST API 호출 (CalDAV 프로토콜 또는 iCloud Calendar API)

### 미들웨어

- **API 서버**: Express (Node.js) 또는 Flask (Python)
- **데이터 저장**: 
  - 경량 옵션: JSON 파일, SQLite
  - 확장 옵션: PostgreSQL, MongoDB (필요 시)

### 인프라 구성

**추천 구성**:

```
Frontend (정적 호스팅)
├── Vercel 또는 Netlify
└── React/Vue 빌드 결과물

Backend (서버리스 함수)
├── Vercel Functions 또는 AWS Lambda
└── 크롤링 작업 및 API 엔드포인트

Data Storage
├── 로컬 파일 시스템 (JSON)
└── 또는 클라우드 스토리지 (S3, Vercel Blob)
```

**대안 구성**:
- 전통적 서버: Node.js/Python 서버 (Railway, Render, Heroku)
- 완전 정적: 클라이언트 사이드 크롤링 (CORS 제약 고려 필요)

### CI/CD 환경

- **GitHub Actions**: 코드 자동 빌드 및 배포
- **Vercel/Netlify**: Git 연동 자동 배포

## 주요 구성 요소 세부 사항

### 각 구성 요소의 책임

#### 1. Frontend (Web UI)

**책임**:
- iCloud OAuth 로그인 UI 제공
- 사용자 입력 인터페이스 제공
- API를 통한 데이터 요청
- 캘린더 UI 렌더링
- 반응형 디자인 구현

**주요 컴포넌트**:
- iCloud 로그인 컴포넌트
- 스포츠 종목 선택 컴포넌트
- 팀 입력 컴포넌트
- 캘린더 컴포넌트
- 경기일정 상세 정보 모달
- iCloud 캘린더 연동 설정 UI

#### 2. Backend (API Server)

**책임**:
- **OAuth 2.0 인증 처리** (iCloud 로그인)
- 크롤링 작업 스케줄링
- 웹 크롤링 실행
- 데이터 파싱 및 정제
- **iCloud Calendar API 연동** (경기일정 전송)
- API 엔드포인트 제공
- 데이터 캐싱 관리
- 사용자별 데이터 격리

**주요 모듈**:
- OAuth 인증 핸들러
- 크롤링 스케줄러
- 웹 크롤링 로직
- 데이터 파서
- iCloud Calendar API 클라이언트
- API 라우터

#### 3. Data Layer

**책임**:
- 크롤링 데이터 저장
- 캐시 관리
- 데이터 조회

**저장 형식**:
- JSON 파일 (경량 옵션)
- SQLite 데이터베이스 (선택)

### 구성 요소 간의 인터페이스

```
Frontend ←→ Backend API (RESTful)
    │            │
    │            ↓
    │      Crawler Module
    │            │
    │            ↓
    └────→ Data Storage
```

**API 엔드포인트 (예시)**:
- **인증**:
  - `GET /api/auth/icloud`: iCloud OAuth 로그인 시작
  - `GET /api/auth/icloud/callback`: iCloud OAuth 콜백
  - `POST /api/auth/logout`: 로그아웃
- **경기일정**:
  - `GET /api/schedule?sport={sport}&team={team}`: 경기일정 조회 (인증 필요)
  - `POST /api/crawl?sport={sport}&team={team}`: 크롤링 실행 (수동 트리거, 인증 필요)
  - `GET /api/teams?sport={sport}`: 지원 팀 목록 (선택)
- **캘린더 연동**:
  - `POST /api/calendar/sync`: 경기일정을 iCloud 캘린더에 동기화 (인증 필요)
  - `GET /api/calendar/status`: 캘린더 연동 상태 확인 (인증 필요)
  - `PUT /api/calendar/settings`: 캘린더 연동 설정 (인증 필요)

### 데이터 모델

```json
{
  "sport": "야구",
  "team": "LG 트윈스",
  "schedule": [
    {
      "date": "2024-03-15",
      "time": "18:30",
      "opponent": "KT 위즈",
      "venue": "잠실야구장",
      "type": "홈"
    }
  ]
}
```

## 구현 정책

### 개발 환경

- **버전 관리**: Git + GitHub
- **패키지 관리**: npm (Node.js) 또는 pip (Python)
- **로컬 개발 서버**: 
  - Frontend: Vite, Create React App, 또는 Next.js
  - Backend: Express 개발 서버 또는 Flask 개발 서버

### 테스트 전략

- **단위 테스트**: 각 모듈별 단위 테스트
- **통합 테스트**: API 엔드포인트 테스트
- **E2E 테스트**: 크롤링 → 데이터 저장 → UI 표시 전체 플로우 테스트
- **크롤링 테스트**: 크롤링 대상 사이트 변경 대응 테스트

### 배포 전략

1. **개발 환경**: 로컬 개발
2. **스테이징 환경**: Vercel/Netlify Preview 배포 (선택)
3. **프로덕션 환경**: Vercel/Netlify 프로덕션 배포

**배포 프로세스**:
1. 코드 커밋 및 푸시
2. GitHub Actions 또는 Vercel/Netlify 자동 빌드
3. 자동 배포 및 확인

## 위험과 대책

### 식별된 위험

#### 1. 크롤링 대상 사이트 변경

**위험**: 크롤링 대상 사이트의 HTML 구조 변경 시 크롤링 실패

**대책**:
- 크롤링 로직을 모듈화하여 유지보수 용이
- 정기적인 크롤링 테스트
- 에러 로깅 및 알림 시스템 (선택)

#### 2. 크롤링 차단

**위험**: 크롤링 대상 사이트에서 IP 차단 또는 Rate Limiting

**대책**:
- 적절한 요청 간격 유지 (Rate Limiting)
- robots.txt 준수
- User-Agent 설정
- 필요 시 프록시 사용 (선택)

#### 3. 데이터 정확성

**위험**: 크롤링한 데이터의 정확성 문제

**대책**:
- 데이터 검증 로직 구현
- 수동 확인 기능 제공 (선택)

#### 4. 서버리스 함수 제한

**위험**: 서버리스 함수의 실행 시간 제한 (예: Vercel 10초, Lambda 15분)

**대책**:
- 크롤링 작업을 비동기로 처리
- 작업 큐 시스템 사용 (선택)
- 전통적 서버로 전환 (필요 시)

#### 5. CORS 제약

**위험**: 클라이언트 사이드에서 직접 크롤링 시 CORS 제약

**대책**:
- 백엔드 API를 통한 크롤링 (권장)
- CORS 프록시 사용 (비권장, 보안 위험)

#### 6. iCloud OAuth 토큰 관리

**위험**: OAuth 토큰 만료 및 갱신 실패

**대책**:
- 토큰 만료 전 자동 갱신 (Refresh Token 활용)
- 토큰 만료 시 사용자에게 재로그인 안내
- 토큰 안전한 저장 (암호화된 데이터베이스 또는 환경 변수)

#### 7. iCloud Calendar API 제한

**위험**: iCloud Calendar API Rate Limiting 및 할당량 초과

**대책**:
- API 호출 빈도 제한 (예: 초당 10회 이하)
- 배치 처리로 여러 경기일정을 한 번에 전송
- 실패 시 재시도 로직 (Exponential Backoff)
- 사용자에게 API 제한 상태 표시

#### 8. 데이터 격리

**위험**: 사용자별 데이터 혼선 (다중 사용자 지원 시)

**대책**:
- 모든 데이터 조회 시 사용자 ID 필터링
- 데이터베이스 레벨에서 사용자별 접근 제어

### 대응책 요약

- 모듈화된 크롤링 로직
- 에러 처리 및 로깅
- Rate Limiting 및 robots.txt 준수
- 데이터 검증
- 비동기 크롤링 처리
- OAuth 토큰 자동 갱신
- iCloud Calendar API Rate Limiting 준수
- 사용자별 데이터 격리

## 비고

### 향후 고려사항

1. **크롤링 대상 확장**: 여러 스포츠 종목 및 팀 지원
2. **기능 확장**: 경기 결과, 알림 기능 추가
3. **사용자 인증**: ✅ **iCloud OAuth 인증 구현 완료 요구**
4. **캘린더 연동**: ✅ **iCloud Calendar API 연동 구현 완료 요구**
5. **다중 사용자 지원**: 이미 사용자 인증이 필요하므로 다중 사용자 지원 가능
6. **데이터베이스 전환**: 대용량 데이터 처리 시 데이터베이스 도입
7. **실시간 업데이트**: WebSocket을 통한 실시간 데이터 업데이트 (선택)
8. **다른 캘린더 서비스**: Google Calendar, Outlook 등 추가 지원 (선택)

### 유의점

1. **법적 준수**: 크롤링 시 웹사이트 이용약관 및 robots.txt 준수
2. **리소스 관리**: 크롤링 빈도 조절로 대상 사이트 부하 최소화
3. **에러 처리**: 크롤링 실패 시 사용자에게 명확한 피드백 제공
4. **성능 최적화**: 캐싱 전략으로 불필요한 크롤링 방지
5. **사용자 경험**: 10살 아동이 이해하기 쉬운 UI/UX 설계

### 추가 정보 수집 필요

ADR 작성에 필요한 다음 정보를 수집해야 합니다:

1. **스포츠 종목 및 팀 정보**: 구체적인 스포츠 종목과 팀 이름
2. **크롤링 대상 웹사이트**: URL 및 API 제공 여부
3. **기술 스택 선호도**: 개발자가 선호하는 언어/프레임워크
4. **배포 환경**: 로컬/클라우드 선호도
5. **예산 및 일정**: 프로젝트 예산 및 완료 일정
6. ✅ **iCloud 연동 설정**: 
   - 경기일정 전송 방식 (자동/수동)
   - 캘린더 선택 (기존 캘린더 사용/새 캘린더 생성)
   - 경기일정 업데이트 정책 (전체 재동기화/증분 업데이트)

이 정보가 수집되면 ADR을 더 구체화할 수 있습니다.

### iCloud 연동 관련 주요 고려사항

#### Apple Developer 등록 필요

iCloud OAuth를 사용하려면:
- Apple Developer Program 가입 필요 (연간 $99)
- App ID 및 Service ID 생성
- OAuth 2.0 설정 (Redirect URI, Client ID/Secret)

#### iCloud Calendar API 접근 방법

1. **CalDAV 프로토콜** (권장)
   - 표준 프로토콜로 안정적
   - iCloud CalDAV 서버 사용
   - URL: `https://caldav.icloud.com/`

2. **iCloud Web API** (제한적)
   - 공식 API가 제한적일 수 있음
   - CalDAV 사용 권장

#### 구현 시 주의사항

- OAuth 토큰은 반드시 서버 측에서 저장 (클라이언트에 노출 금지)
- 토큰은 암호화하여 저장
- Refresh Token을 활용한 자동 토큰 갱신
- iCloud Calendar API Rate Limiting 준수 (초당 10회 이하 권장)

---

**작성일**: 2024-12-19
**작성자**: AI 아키텍트
**상태**: 제안 (승인 대기)

