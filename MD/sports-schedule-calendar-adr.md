# ADR-001: 스포츠팀 경기일정 캘린더 웹사이트 아키텍처 결정

## 배경

### 결정이 필요한 배경

10살 아들이 좋아하는 스포츠팀의 경기일정을 자동으로 수집하여 캘린더 형태로 시각화하는 웹 애플리케이션을 개발합니다. 현재는 여러 웹사이트를 수동으로 방문하여 텍스트 형태의 정보를 확인해야 하는 불편함이 있으며, 이를 자동화하고 시각화하는 것이 목표입니다.

### 현재의 과제

1. **정보 수집의 번거로움**: 여러 웹사이트를 직접 방문하여 경기일정 확인
2. **시각화 부족**: 텍스트 형태로만 제공되어 한눈에 파악하기 어려움
3. **사용자 경험**: 10살 아동이 이해하기 쉬운 직관적인 UI/UX 필요
4. **캘린더 연동**: 경기일정을 iCloud 캘린더에 자동으로 동기화하여 다른 기기에서도 확인 가능하도록 필요

### 아키텍처 드라이버 개요

#### 제약 사항

**비즈니스상의 제약**:
- **프로젝트 예산**: 미정 (개인/가족 프로젝트로 저예산 가정)
- **일정**: 미정 (긴급하지 않음)
- **릴리스 마감일**: 없음
- **운영 후 유지보수 비용**: 최소화 필요
- **법규 대응**: 특별한 법규 요구사항 없음 (단, 웹 크롤링 시 robots.txt 및 이용약관 준수 필요)

**기술적인 제약**:
- **프로그래밍 언어**: 미정 (선택 필요)
- **사용 가능한 라이브러리·프레임워크**: 미정
- **환경**: 미정 (로컬/클라우드 선택 필요)
- **기존 시스템과의 연계**: 없음

#### 품질 특성

**가용성(신뢰성)**:
- 가동률: 95% 이상 (개인용 프로젝트로 높은 가용성 불필요)
- 장애 복구 시간: 24시간 이내 (수동 재시작 가능)

**성능**:
- 응답 시간: 2초 이내 (일반 웹사이트 수준)
- 처리량: 동시 사용자 10명 이하 (개인/가족 사용)
- 크롤링 속도: 일별 또는 주별 크롤링으로 충분
- 페이지 로드 시간: 3초 이내

**보안**:
- 인증 방식: ✅ **Google OAuth 2.0 인증 필요** (iCloud → Google 변경)
- 데이터 보호: 
  - Google OAuth 토큰 안전한 저장 (암호화 필요)
  - 사용자별 데이터 격리 필요
- 크롤링 시 robots.txt 준수 및 적절한 요청 간격 유지
- Google Calendar API 호출 시 Rate Limiting 준수 (초당 100 쿼리)

**유지보수성**:
- 크롤링 대상 사이트 변경에 대응 가능한 구조 필요
- 코드 가독성 및 간결성 중시
- 신규 기능 추가 시 개발 시간: 기존 기능의 20% 이하 추가 개발 시간

**이식성**:
- 다른 환경으로의 이전 용이성: 중간 정도 중요
- 환경 변경 시 마이그레이션 시간: 1주 이내

**법규 및 업계 표준 준수 요구사항**:
- 웹 크롤링: robots.txt 준수 필수
- 개인정보보호: Google OAuth 토큰 암호화 저장 (AES-256)
- Google API 사용 정책 준수
- 데이터 보존: 5년 이상 (선택)

**분산 시스템 요구사항**:
- 실시간성: 불필요 (일별/주별 업데이트 충분)
- 지연 요구사항: 없음
- 데이터 일관성: 최종 일관성 (Eventual Consistency) 허용

**환경 요구사항**:
- 모바일 및 데스크톱 브라우저 지원
- 반응형 디자인 필수
- 지원 브라우저: Chrome, Safari, Firefox (최신 2개 버전)

#### 아키텍처에 영향을 주는 기능 요구사항

1. **인증 시스템**: ✅ **Google 계정으로 로그인 (OAuth 2.0)** (iCloud → Google 변경)
2. **사용자 입력 인터페이스**: 스포츠 종목 및 팀 선택
3. **웹 크롤링**: 경기일정 데이터 자동 수집
4. **데이터 파싱 및 저장**: 수집한 데이터 정제 및 저장
5. **캘린더 시각화**: 경기일정을 캘린더 형태로 표시
6. **외부 캘린더 연동**: ✅ **Google Calendar API를 통한 경기일정 자동 전송** (iCloud → Google 변경)
7. **캘린더 공유 기능**: 가족/친구와 캘린더 공유 (선택)
8. **알림 시스템**: Google Calendar 알림 통합 (이메일, 푸시)
9. **반응형 UI**: 모바일 및 데스크톱 지원

**향후 기능 확장 계획**:
- 다중 팀 지원 (선택)
- 경기 결과 표시 (선택)
- 알림/리마인더 기능 (선택)

#### 기타 영향 요소

- **개발 팀의 기술 수준**: 개인 개발자 (부모)
- **운영 팀의 체제**: 개발자 본인이 운영
- **이해관계자의 요구**: 10살 아동의 사용성 중시

## 결정 내용

### 선택한 아키텍처 패턴

**모놀리식 아키텍처**를 선택했습니다.

이유:
- 소규모 개인 프로젝트로 복잡한 분산 아키텍처 불필요
- 개발 및 운영 비용 최소화
- 단일 애플리케이션으로 충분한 기능 제공
- 빠른 개발 및 배포 가능

### 주요 구성 요소 구성

```
┌─────────────────────────────────────────┐
│         Frontend (Web UI)                │
│  - React/Vue/Angular 또는 순수 JS        │
│  - 캘린더 컴포넌트                       │
│  - 사용자 입력 인터페이스                │
│  - Google OAuth 로그인 UI                │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Backend (API Server)             │
│  - RESTful API                            │
│  - Google OAuth 2.0 인증 처리            │
│  - 크롤링 스케줄러                        │
│  - 데이터 파싱 로직                       │
│  - Google Calendar API 클라이언트        │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         Data Layer                       │
│  - 파일 시스템 또는 경량 DB              │
│  - 크롤링 데이터 캐시                     │
│  - 사용자 인증 정보 (암호화)              │
│  - Google OAuth 토큰 (암호화)             │
└─────────────────────────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│         External APIs                    │
│  - Google Calendar API (REST)            │
│  - Google OAuth 2.0 서버                 │
└─────────────────────────────────────────┘
```

### 인프라

**배포 환경 옵션** (선택 필요):
1. **로컬 환경**: 개발자 PC에서 실행
2. **클라우드 호스팅**: Vercel, Netlify, GitHub Pages (정적 호스팅)
3. **클라우드 서버**: AWS, GCP, Azure (서버리스 또는 전통적 서버)

**추천**: 초기 단계에서는 **정적 호스팅 + 서버리스 함수** 조합
- Vercel/Netlify: 프론트엔드 호스팅
- 서버리스 함수: 크롤링 작업 (예: Vercel Functions, AWS Lambda)

### 데이터 흐름

#### 기본 경기일정 조회 플로우

```
사용자 입력 (스포츠 종목, 팀)
    ↓
Frontend → API 요청 (인증 토큰 포함)
    ↓
Backend → 사용자 인증 확인
    ↓
Backend → 크롤링 작업 실행 (또는 캐시된 데이터 반환)
    ↓
데이터 파싱 및 정제
    ↓
데이터 저장 (캐시)
    ↓
Frontend에 JSON 응답
    ↓
캘린더 UI에 데이터 표시
```

#### Google 캘린더 동기화 플로우

```
경기일정 크롤링 완료
    ↓
사용자별 캘린더 설정 확인 (auto_sync = true)
    ↓
Backend → Google OAuth 토큰 조회 (암호화된 저장소)
    ↓
토큰 만료 확인 → 필요 시 자동 갱신 (Refresh Token)
    ↓
Google Calendar API 호출 (REST API)
    ↓
경기일정을 Google Calendar Event 형식으로 변환
    ↓
이벤트 생성/업데이트 (배치 요청 가능)
    ↓
알림 설정 (이메일, 푸시) 적용
    ↓
동기화 이력 저장 (calendar_sync_history)
    ↓
동기화 성공/실패 상태 반환
```

## 상태

**제안** (승인 대기)

## 선정 이유

### 아키텍처 비교 평가 결과

doc02-adr.mdc 가이드에 따라 다음 평가 항목을 기준으로 비교합니다:

| 평가 항목 | 모놀리식 | 마이크로서비스 | 서버리스 |
|----------|---------|--------------|---------|
| **시간 효율성** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 개발 시간 | 2-3주 | 8-12주 | 4-6주 |
| 초기 배포 시간 | 1일 | 2-3주 | 3-5일 |
| **분석 가능성·로그** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| 로그 수집 용이성 | 매우 쉬움 (단일 앱) | 중간 (여러 서비스) | 어려움 (분산) |
| 디버깅 난이도 | 쉬움 | 어려움 | 매우 어려움 |
| **분석 가능성·성능** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 성능 모니터링 | 단일 앱 모니터링 | 각 서비스별 모니터링 | 서버리스 메트릭 활용 |
| 성능 튜닝 용이성 | 쉬움 | 중간 | 어려움 |
| **개발 팀의 기술 수준** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| 요구 기술 수준 | 낮음 (개인 개발자 적합) | 높음 (분산 시스템 경험 필요) | 중간 (서버리스 경험 필요) |
| 학습 곡선 | 낮음 | 높음 | 중간 |
| **개발 공수** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| 초기 개발 공수 | 낮음 | 매우 높음 | 중간 |
| 유지보수 공수 | 낮음 | 높음 | 중간 |
| **비용** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 인프라 비용 | 매우 낮음 | 높음 | 중간 (사용량 기반) |
| 운영 비용 | 낮음 | 높음 | 중간 |
| **확장성** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 수평 확장 | 제한적 | 우수 | 우수 |
| 수직 확장 | 가능 | 가능 | 제한적 |
| **유지보수성** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| 코드 변경 영향도 | 낮음 | 높음 (서비스 간 영향) | 중간 |
| 배포 복잡도 | 낮음 | 높음 | 중간 |

**결론**: 개인 프로젝트의 특성상 **모놀리식 아키텍처**가 가장 적합합니다.

### 선정한 이유의 상세 설명

#### 1. 시간 효율성
- **개발 시간**: 단일 코드베이스로 2-3주 내 개발 가능 (마이크로서비스 대비 4-6배 빠름)
- **초기 배포**: 1일 내 배포 가능 (마이크로서비스는 2-3주 소요)
- **개발 효율성**: 단일 저장소로 빠른 개발 및 디버깅 가능

#### 2. 분석 가능성
- **로그 분석**: 단일 애플리케이션 로그로 모든 이슈 추적 가능
- **디버깅**: 전체 플로우를 한 곳에서 추적 가능하여 문제 해결 용이
- **성능 모니터링**: 단일 애플리케이션 메트릭으로 충분

#### 3. 개발 팀 기술 수준
- **개인 개발자**: 복잡한 분산 시스템 경험 불필요
- **학습 곡선**: 낮은 학습 곡선으로 빠른 개발 시작 가능
- **기술 스택**: 익숙한 기술 스택으로 충분히 구현 가능

#### 4. 개발 공수
- **초기 개발 공수**: 최소화 (개인 프로젝트에 적합)
- **유지보수 공수**: 낮음 (단일 코드베이스 관리)
- **기능 추가**: 기존 기능의 20% 이하 추가 시간으로 신규 기능 추가 가능

#### 5. 비용 효율성
- **인프라 비용**: 매우 낮음 (단일 서버 또는 서버리스 함수)
- **운영 비용**: 최소화 (개인 프로젝트 예산에 적합)
- **확장 비용**: 초기 단계에서는 불필요

#### 6. 기능 제공
- **충분한 기능 제공**: 현재 요구사항을 모놀리식으로 충분히 충족
- **iCloud 연동**: 단일 애플리케이션에서 OAuth 및 Calendar API 처리 가능

#### 7. 향후 확장성
- **점진적 전환**: 필요 시 점진적으로 마이크로서비스로 전환 가능
- **모듈화**: 초기부터 모듈화 설계로 전환 용이

## 영향

### 이 결정의 영향

**긍정적 영향**:
- 빠른 개발 및 배포 가능
- 간단한 운영 및 유지보수
- 낮은 운영 비용

**부정적 영향**:
- 대규모 확장 시 제약 가능
- 단일 장애점 존재

### 개발 프로세스에 미치는 영향

- 단일 저장소로 코드 관리 간소화
- 통합 테스트 용이
- 배포 프로세스 단순화

### 운영에 미치는 영향

- 단일 애플리케이션 모니터링
- 로그 관리 용이
- 장애 대응 단순화

### 향후 확장성에 미치는 영향

- 초기 단계에서는 충분
- 사용자 증가 또는 기능 확장 시 점진적 리팩토링 가능
- 마이크로서비스 전환 가능 (필요 시)

## 비기능 요구사항 대응

### 가용성 대응

- 개인 프로젝트 특성상 높은 가용성 불필요
- 서버리스 함수 사용 시 자동 스케일링 활용
- 정적 호스팅으로 프론트엔드 고가용성 확보

### 성능 대응

- 캐싱 전략으로 크롤링 빈도 최소화
- 정적 파일 CDN 활용
- 클라이언트 사이드 렌더링으로 빠른 응답

### 보안 대응

- 크롤링 시 robots.txt 준수
- 적절한 요청 간격 유지 (Rate Limiting)
- 사용자 입력 검증 및 Sanitization
- HTTPS 사용

### 기타 중요한 비기능 요건 대응

**사용성**: 10살 아동을 위한 직관적 UI
**접근성**: 모바일 및 데스크톱 반응형 디자인
**유지보수성**: 크롤링 대상 사이트 변경에 대응 가능한 구조

## 대안

### 고려한 다른 아키텍처 패턴

#### 1. 마이크로서비스 아키텍처

**선택하지 않은 이유**:
- 소규모 프로젝트에 과도한 복잡성
- 개발 및 운영 비용 증가
- 불필요한 오버헤드

#### 2. 서버리스 아키텍처 (함수 중심)

**고려 사항**:
- 장점: 자동 스케일링, 비용 효율적 (사용량 기반)
- 단점: 콜드 스타트, 디버깅 복잡성

**최종 판단**: 서버리스 함수를 크롤링 작업에 활용하는 하이브리드 접근 가능

## 기술 스택

### 채택하는 언어/프레임워크 (추천)

**프론트엔드**:
- **옵션 1**: React + TypeScript (권장)
  - 풍부한 캘린더 라이브러리 (react-big-calendar, fullcalendar-react)
  - 활발한 커뮤니티
- **옵션 2**: Vue.js + TypeScript
- **옵션 3**: 순수 JavaScript (간단한 프로젝트)

**백엔드**:
- **옵션 1**: Node.js + Express (권장)
  - 프론트엔드와 동일한 언어로 풀스택 개발 가능
  - 크롤링 라이브러리 풍부 (Puppeteer, Cheerio)
- **옵션 2**: Python + Flask/FastAPI
  - 크롤링에 최적화 (BeautifulSoup, Scrapy)
  - 데이터 처리에 강점
- **옵션 3**: 서버리스 함수 (Vercel Functions, AWS Lambda)

**크롤링 라이브러리**:
- Node.js: Puppeteer, Cheerio, Axios
- Python: BeautifulSoup, Scrapy, Selenium

**인증 및 외부 API 라이브러리**:
- **Google OAuth 2.0**: 
  - Node.js: `google-auth-library`, `passport-google-oauth20`, `googleapis`
  - Python: `google-auth`, `google-auth-oauthlib`, `google-api-python-client`
- **Google Calendar API**:
  - Node.js: `googleapis` (공식 SDK, Google Calendar API 포함)
  - Python: `google-api-python-client` (공식 SDK)
  - REST API 직접 호출 (선택)

### 미들웨어

- **API 서버**: Express (Node.js) 또는 Flask (Python)
- **데이터 저장**: 
  - 경량 옵션: JSON 파일, SQLite
  - 확장 옵션: PostgreSQL, MongoDB (필요 시)

### 인프라 구성

**추천 구성**:

```
Frontend (정적 호스팅)
├── Vercel 또는 Netlify
└── React/Vue 빌드 결과물

Backend (서버리스 함수)
├── Vercel Functions 또는 AWS Lambda
└── 크롤링 작업 및 API 엔드포인트

Data Storage
├── 로컬 파일 시스템 (JSON)
└── 또는 클라우드 스토리지 (S3, Vercel Blob)
```

**대안 구성**:
- 전통적 서버: Node.js/Python 서버 (Railway, Render, Heroku)
- 완전 정적: 클라이언트 사이드 크롤링 (CORS 제약 고려 필요)

### CI/CD 환경

- **GitHub Actions**: 코드 자동 빌드 및 배포
- **Vercel/Netlify**: Git 연동 자동 배포

## 주요 구성 요소 세부 사항

### 각 구성 요소의 책임

#### 1. Frontend (Web UI)

**책임**:
- Google OAuth 로그인 UI 제공
- 사용자 입력 인터페이스 제공
- API를 통한 데이터 요청
- 캘린더 UI 렌더링
- 반응형 디자인 구현

**주요 컴포넌트**:
- Google 로그인 컴포넌트 (Google Design 가이드 준수)
- 스포츠 종목 선택 컴포넌트
- 팀 입력 컴포넌트
- 캘린더 컴포넌트
- 경기일정 상세 정보 모달
- Google 캘린더 연동 설정 UI
- 캘린더 선택 UI (드롭다운 또는 리스트)
- 알림 설정 UI (이메일, 푸시, 시점)

#### 2. Backend (API Server)

**책임**:
- **Google OAuth 2.0 인증 처리** (Google 로그인)
- 크롤링 작업 스케줄링
- 웹 크롤링 실행
- 데이터 파싱 및 정제
- **Google Calendar API 연동** (경기일정 전송)
- **캘린더 공유 기능** (선택)
- **알림 설정 관리** (이메일, 푸시)
- API 엔드포인트 제공
- 데이터 캐싱 관리
- 사용자별 데이터 격리
- API 할당량 모니터링

**주요 모듈**:
- Google OAuth 인증 핸들러
- 크롤링 스케줄러
- 웹 크롤링 로직
- 데이터 파서
- Google Calendar API 클라이언트
- 알림 관리 모듈
- 캘린더 공유 모듈 (선택)
- API 라우터

#### 3. Data Layer

**책임**:
- 크롤링 데이터 저장
- 캐시 관리
- 데이터 조회

**저장 형식**:
- JSON 파일 (경량 옵션)
- SQLite 데이터베이스 (선택)

### 구성 요소 간의 인터페이스

```
Frontend ←→ Backend API (RESTful)
    │            │
    │            ↓
    │      Crawler Module
    │            │
    │            ↓
    └────→ Data Storage
```

**API 엔드포인트 (예시)**:
- **인증**:
  - `GET /api/auth/google`: Google OAuth 로그인 시작
  - `GET /api/auth/google/callback`: Google OAuth 콜백
  - `POST /api/auth/logout`: 로그아웃
- **경기일정**:
  - `GET /api/schedule?sport={sport}&team={team}`: 경기일정 조회 (인증 필요)
  - `POST /api/crawl?sport={sport}&team={team}`: 크롤링 실행 (수동 트리거, 인증 필요)
  - `GET /api/teams?sport={sport}`: 지원 팀 목록 (선택)
- **캘린더 연동**:
  - `GET /api/calendar/list`: 사용자의 Google 캘린더 목록 조회 (인증 필요)
  - `POST /api/calendar/sync`: 경기일정을 Google 캘린더에 동기화 (인증 필요)
  - `GET /api/calendar/status`: 캘린더 연동 상태 확인 (인증 필요)
  - `PUT /api/calendar/settings`: 캘린더 연동 설정 (인증 필요)
  - `POST /api/calendar/share`: 캘린더 공유 설정 (선택, 인증 필요)
  - `PUT /api/calendar/notifications`: 알림 설정 (이메일, 푸시, 인증 필요)

### 데이터 모델

```json
{
  "sport": "야구",
  "team": "LG 트윈스",
  "schedule": [
    {
      "date": "2024-03-15",
      "time": "18:30",
      "opponent": "KT 위즈",
      "venue": "잠실야구장",
      "type": "홈"
    }
  ]
}
```

## 구현 정책

### 개발 환경

- **버전 관리**: Git + GitHub
- **패키지 관리**: npm (Node.js) 또는 pip (Python)
- **로컬 개발 서버**: 
  - Frontend: Vite, Create React App, 또는 Next.js
  - Backend: Express 개발 서버 또는 Flask 개발 서버

### 테스트 전략

- **단위 테스트**: 각 모듈별 단위 테스트
- **통합 테스트**: API 엔드포인트 테스트
- **E2E 테스트**: 크롤링 → 데이터 저장 → UI 표시 전체 플로우 테스트
- **크롤링 테스트**: 크롤링 대상 사이트 변경 대응 테스트

### 배포 전략

1. **개발 환경**: 로컬 개발
2. **스테이징 환경**: Vercel/Netlify Preview 배포 (선택)
3. **프로덕션 환경**: Vercel/Netlify 프로덕션 배포

**배포 프로세스**:
1. 코드 커밋 및 푸시
2. GitHub Actions 또는 Vercel/Netlify 자동 빌드
3. 자동 배포 및 확인

## 위험과 대책

### 식별된 위험

#### 1. 크롤링 대상 사이트 변경

**위험**: 크롤링 대상 사이트의 HTML 구조 변경 시 크롤링 실패

**대책**:
- 크롤링 로직을 모듈화하여 유지보수 용이
- 정기적인 크롤링 테스트
- 에러 로깅 및 알림 시스템 (선택)

#### 2. 크롤링 차단

**위험**: 크롤링 대상 사이트에서 IP 차단 또는 Rate Limiting

**대책**:
- 적절한 요청 간격 유지 (Rate Limiting)
- robots.txt 준수
- User-Agent 설정
- 필요 시 프록시 사용 (선택)

#### 3. 데이터 정확성

**위험**: 크롤링한 데이터의 정확성 문제

**대책**:
- 데이터 검증 로직 구현
- 수동 확인 기능 제공 (선택)

#### 4. 서버리스 함수 제한

**위험**: 서버리스 함수의 실행 시간 제한 (예: Vercel 10초, Lambda 15분)

**대책**:
- 크롤링 작업을 비동기로 처리
- 작업 큐 시스템 사용 (선택)
- 전통적 서버로 전환 (필요 시)

#### 5. CORS 제약

**위험**: 클라이언트 사이드에서 직접 크롤링 시 CORS 제약

**대책**:
- 백엔드 API를 통한 크롤링 (권장)
- CORS 프록시 사용 (비권장, 보안 위험)

#### 6. Google OAuth 토큰 관리

**위험**: OAuth 토큰 만료 및 갱신 실패

**대책**:
- 토큰 만료 전 자동 갱신 (Refresh Token 활용)
- Google OAuth 라이브러리의 자동 토큰 갱신 기능 활용
- 토큰 만료 시 사용자에게 재로그인 안내
- 토큰 안전한 저장 (암호화된 데이터베이스 또는 환경 변수)

#### 7. Google Calendar API 제한

**위험**: Google Calendar API Rate Limiting 및 할당량 초과

**대책**:
- API 호출 빈도 제한 (초당 100 쿼리 이하)
- 일일 할당량 모니터링 (1,000,000 쿼리/일)
- 배치 요청(Batch Request)으로 여러 이벤트 동시 처리
- 실패 시 재시도 로직 (Exponential Backoff)
- 사용자에게 API 제한 상태 표시
- 할당량 초과 시 대기 및 재시도

#### 8. 데이터 격리

**위험**: 사용자별 데이터 혼선 (다중 사용자 지원 시)

**대책**:
- 모든 데이터 조회 시 사용자 ID 필터링
- 데이터베이스 레벨에서 사용자별 접근 제어

### 대응책 요약

- 모듈화된 크롤링 로직
- 에러 처리 및 로깅
- Rate Limiting 및 robots.txt 준수
- 데이터 검증
- 비동기 크롤링 처리
- Google OAuth 토큰 자동 갱신
- Google Calendar API Rate Limiting 준수 (초당 100 쿼리)
- API 할당량 모니터링 (일일 1,000,000 쿼리)
- 사용자별 데이터 격리

## 비고

### 향후 고려사항

1. **크롤링 대상 확장**: 여러 스포츠 종목 및 팀 지원
2. **기능 확장**: 경기 결과 표시 추가
3. **사용자 인증**: ✅ **Google OAuth 인증 구현 완료 요구** (iCloud → Google 변경)
4. **캘린더 연동**: ✅ **Google Calendar API 연동 구현 완료 요구** (iCloud → Google 변경)
5. **캘린더 공유**: 가족/친구와 캘린더 공유 기능 (선택)
6. **알림 시스템**: Google Calendar 알림 통합 (이메일, 푸시)
7. **다중 사용자 지원**: 이미 사용자 인증이 필요하므로 다중 사용자 지원 가능
8. **데이터베이스 전환**: 대용량 데이터 처리 시 데이터베이스 도입
9. **실시간 업데이트**: WebSocket을 통한 실시간 데이터 업데이트 (선택)
10. **다른 캘린더 서비스**: Outlook, Apple Calendar 등 추가 지원 (선택)

### 유의점

1. **법적 준수**: 크롤링 시 웹사이트 이용약관 및 robots.txt 준수
2. **리소스 관리**: 크롤링 빈도 조절로 대상 사이트 부하 최소화
3. **에러 처리**: 크롤링 실패 시 사용자에게 명확한 피드백 제공
4. **성능 최적화**: 캐싱 전략으로 불필요한 크롤링 방지
5. **사용자 경험**: 10살 아동이 이해하기 쉬운 UI/UX 설계

### 추가 정보 수집 필요

ADR 작성에 필요한 다음 정보를 수집해야 합니다:

1. **스포츠 종목 및 팀 정보**: 구체적인 스포츠 종목과 팀 이름
2. **크롤링 대상 웹사이트**: URL 및 API 제공 여부
3. **기술 스택 선호도**: 개발자가 선호하는 언어/프레임워크
4. **배포 환경**: 로컬/클라우드 선호도
5. **예산 및 일정**: 프로젝트 예산 및 완료 일정
6. ✅ **Google 캘린더 연동 설정**: 
   - 경기일정 전송 방식 (자동/수동)
   - 캘린더 선택 (기본 캘린더 사용/새 캘린더 생성)
   - 경기일정 업데이트 정책 (전체 재동기화/증분 업데이트)
   - 캘린더 공유 필요 여부
   - 알림 설정 (이메일, 푸시, 알림 시점)

이 정보가 수집되면 ADR을 더 구체화할 수 있습니다.

### Google 캘린더 연동 관련 주요 고려사항

#### Google Cloud Platform 설정

Google OAuth 및 Calendar API를 사용하려면:
- ✅ **Google Cloud Platform 프로젝트 생성** (무료)
- ✅ **OAuth 2.0 클라이언트 ID 및 Secret 발급** (무료)
- ✅ **Google Calendar API 활성화** (무료)
- ✅ **승인된 리디렉션 URI 설정**
- ✅ **OAuth 동의 화면 설정** (개인용 프로젝트는 간소화 가능)

**장점**: Apple Developer Program 가입 불필요 (연간 $99 절약)

#### Google Calendar API 접근 방법

1. **Google Calendar API (REST)** (권장)
   - 공식 REST API로 잘 문서화됨
   - 다양한 프로그래밍 언어 지원
   - 풍부한 기능 제공
   - URL: `https://www.googleapis.com/calendar/v3/`

2. **Google API 클라이언트 라이브러리** (권장)
   - Node.js: `googleapis` 패키지
   - Python: `google-api-python-client`
   - 자동 토큰 갱신 및 에러 처리 지원

#### Google Calendar API 주요 기능

- **이벤트 관리**: 생성, 수정, 삭제, 조회
- **캘린더 관리**: 목록 조회, 생성, 수정, 삭제
- **알림 설정**: 이메일, 푸시 알림
- **공유 기능**: 캘린더 공유, 권한 설정
- **색상 설정**: 이벤트 및 캘린더 색상 지정
- **위치 정보**: Google Maps 연동 가능

#### 구현 시 주의사항

- OAuth 토큰은 반드시 서버 측에서 저장 (클라이언트에 노출 금지)
- 토큰은 암호화하여 저장 (AES-256)
- Refresh Token을 활용한 자동 토큰 갱신
- Google Calendar API Rate Limiting 준수 (초당 100 쿼리)
- 일일 할당량 모니터링 (1,000,000 쿼리/일)
- 배치 요청으로 여러 이벤트 동시 처리
- OAuth Scope 최소화 (최소 권한 원칙)
- Google API 사용 정책 준수

---

**작성일**: 2024-12-19
**작성자**: AI 아키텍트
**상태**: 제안 (승인 대기)

